// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.1
// source: user_in_segments.sql

package database

import (
	"context"
)

const addUserIntoSegment = `-- name: AddUserIntoSegment :one
INSERT INTO users_in_segments (user_id, segment_id, created_at, updated_at, expire_at) 
VALUES ($1, (SELECT id FROM segments WHERE $2 = name), now(), now(), null)
ON CONFLICT (user_id, segment_id) DO UPDATE
	SET updated_at = now(), expire_at = null
RETURNING user_id, segment_id, created_at, updated_at, expire_at
`

type AddUserIntoSegmentParams struct {
	UserID      int64
	SegmentName string
}

func (q *Queries) AddUserIntoSegment(ctx context.Context, arg AddUserIntoSegmentParams) (UsersInSegment, error) {
	row := q.db.QueryRowContext(ctx, addUserIntoSegment, arg.UserID, arg.SegmentName)
	var i UsersInSegment
	err := row.Scan(
		&i.UserID,
		&i.SegmentID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpireAt,
	)
	return i, err
}

const addUserIntoSegmentWithTTLInHours = `-- name: AddUserIntoSegmentWithTTLInHours :one
INSERT INTO users_in_segments (user_id, segment_id, created_at, updated_at, expire_at) 
VALUES ($1, (SELECT id FROM segments WHERE $2 = name), now(), now(), now() + make_interval(hours => $3))
ON CONFLICT (user_id, segment_id) DO UPDATE
	SET updated_at = now(), expire_at = now() + make_interval(hours => $3)
RETURNING user_id, segment_id, created_at, updated_at, expire_at
`

type AddUserIntoSegmentWithTTLInHoursParams struct {
	UserID        int64
	SegmentName   string
	NumberOfHours int32
}

func (q *Queries) AddUserIntoSegmentWithTTLInHours(ctx context.Context, arg AddUserIntoSegmentWithTTLInHoursParams) (UsersInSegment, error) {
	row := q.db.QueryRowContext(ctx, addUserIntoSegmentWithTTLInHours, arg.UserID, arg.SegmentName, arg.NumberOfHours)
	var i UsersInSegment
	err := row.Scan(
		&i.UserID,
		&i.SegmentID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpireAt,
	)
	return i, err
}

const getSegmentsByUserId = `-- name: GetSegmentsByUserId :many
SELECT segment_id, name 
FROM users_in_segments
INNER JOIN segments ON segment_id = segments.id
WHERE user_id = $1 AND 
CASE WHEN expire_at IS NOT NULL
THEN expire_at > now()
ELSE TRUE
END
`

type GetSegmentsByUserIdRow struct {
	SegmentID int64
	Name      string
}

func (q *Queries) GetSegmentsByUserId(ctx context.Context, userID int64) ([]GetSegmentsByUserIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getSegmentsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSegmentsByUserIdRow
	for rows.Next() {
		var i GetSegmentsByUserIdRow
		if err := rows.Scan(&i.SegmentID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeUserFromSegment = `-- name: RemoveUserFromSegment :exec
DELETE 
FROM users_in_segments
WHERE user_id = $1 AND 
segment_id = (SELECT id FROM segments WHERE name = $2)
`

type RemoveUserFromSegmentParams struct {
	UserID      int64
	SegmentName string
}

func (q *Queries) RemoveUserFromSegment(ctx context.Context, arg RemoveUserFromSegmentParams) error {
	_, err := q.db.ExecContext(ctx, removeUserFromSegment, arg.UserID, arg.SegmentName)
	return err
}
